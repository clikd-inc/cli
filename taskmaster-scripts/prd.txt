# Clikd CLI Restrukturierungs-PRD

## Einführung

Dieses Dokument enthält einen detaillierten Plan zur Restrukturierung des Clikd-Projekts, einer CLI-Anwendung zur Changelog-Generierung mit KI-Integration. Die vorgeschlagene Struktur basiert auf einer gründlichen Analyse der tatsächlichen Codebase und orientiert sich an Go-Best-Practices für CLI-Anwendungen.

## Aktuelle Analyse der Codebase

### Erkenntnisse aus der Code-Analyse

Nach der vollständigen Durchsicht aller Dateien zeigt sich folgendes Bild:

1. **Tatsächliche Funktionalität**:
   - Clikd ist eine reine CLI-Anwendung für Changelog-Generierung
   - KI-Integration erfolgt ausschließlich über **gollm** (nicht mehrere Provider)
   - Bubble Tea wird für interaktive UI-Komponenten verwendet
   - Die Anwendung integriert git-chglog als Kernfunktionalität

2. **Aktuelle Struktur-Probleme**:
   - Inkonsistente Verwendung von `pkg/` vs. `internal/`
   - `pkg/internal/` ist ein Anti-Pattern (internal sollte nie unter pkg/ stehen)
   - Fragmentierte Konfigurationsverwaltung über mehrere Dateien
   - UI-Komponenten sind teilweise in `models/` statt in UI-Paketen
   - Vermischung von CLI-Logik und Geschäftslogik

3. **Korrekte KI-Architektur**:
   - Alle KI-Funktionen laufen über gollm als einheitliche Schnittstelle
   - Gollm abstrahiert verschiedene Provider (OpenAI, Mistral, Anthropic, etc.)
   - Konfiguration erfolgt über einheitliche API-Schlüssel-Verwaltung

## Empfohlene Zielstruktur

```
clikd/
├── cmd/
│   └── clikd/
│       └── main.go                    # Haupteintrittspunkt
│
├── internal/                          # Private Implementierung (nicht exportierbar)
│   ├── cli/                          # CLI-spezifische Logik
│   │   ├── commands/                 # Cobra-Befehlsimplementierungen
│   │   │   ├── root.go              # Root-Befehl
│   │   │   ├── changelog.go         # Changelog-Befehl
│   │   │   ├── init.go              # Initialisierungsbefehl
│   │   │   └── version.go           # Version-Befehl
│   │   └── flags.go                 # Gemeinsame Flag-Definitionen
│   │
│   ├── core/                        # Kerngeschäftslogik
│   │   ├── changelog/               # Changelog-Generator
│   │   │   ├── generator.go         # Hauptgenerator
│   │   │   ├── parser.go            # Commit-Parser
│   │   │   ├── template.go          # Template-Engine
│   │   │   └── jira.go              # Jira-Integration
│   │   │
│   │   ├── ai/                      # KI-Integration
│   │   │   ├── client.go            # Gollm-Client-Wrapper
│   │   │   ├── prompts.go           # Prompt-Templates
│   │   │   └── enhancement.go       # KI-Verbesserungen
│   │   │
│   │   └── git/                     # Git-Operationen
│   │       ├── repository.go        # Repository-Operationen
│   │       └── commits.go           # Commit-Verarbeitung
│   │
│   ├── config/                      # Konfigurationsverwaltung
│   │   ├── manager.go               # Einheitlicher Manager
│   │   ├── loader.go                # Konfigurationsladung
│   │   ├── types.go                 # Konfigurationstypen
│   │   └── validation.go            # Validierung
│   │
│   ├── ui/                          # Terminal-UI (Bubble Tea)
│   │   ├── models/                  # Bubble Tea Models
│   │   │   ├── init.go             # Initialisierungsmodell
│   │   │   └── progress.go         # Fortschrittsmodell
│   │   ├── components/              # Wiederverwendbare Komponenten
│   │   │   ├── select.go           # Auswahlkomponente
│   │   │   ├── input.go            # Eingabekomponente
│   │   │   └── confirm.go          # Bestätigungskomponente
│   │   └── styles.go               # Gemeinsame Stile
│   │
│   └── utils/                       # Hilfsfunktionen
│       ├── logger.go                # Logging
│       ├── apikey.go                # API-Schlüssel-Verwaltung
│       └── filesystem.go            # Dateisystem-Operationen
│
├── pkg/                             # Öffentliche APIs (falls benötigt)
│   └── version/                     # Versionsinformationen
│       └── version.go
│
├── testdata/                        # Testdaten
├── docs/                           # Dokumentation
├── scripts/                        # Build- und Deployment-Skripte
├── go.mod
├── go.sum
├── README.md
└── .gitignore
```

## Detaillierte Begründungen

### 1. Eliminierung von `pkg/` für interne Logik

**Problem**: Die aktuelle Struktur verwendet `pkg/` für interne CLI-Logik, was gegen Go-Konventionen verstößt.

**Lösung**: 
- `pkg/` nur für echte öffentliche APIs verwenden (z.B. Versionsinformationen)
- Alle CLI-spezifische Logik nach `internal/` verschieben
- Dies macht deutlich, dass clikd eine Anwendung und keine Bibliothek ist

### 2. Klare Trennung von CLI und Geschäftslogik

**Problem**: Cobra-Befehle enthalten zu viel Geschäftslogik.

**Lösung**:
- `internal/cli/commands/`: Nur Cobra-Befehlsdefinitionen und Flag-Handling
- `internal/core/`: Gesamte Geschäftslogik unabhängig von CLI
- Bessere Testbarkeit und Wiederverwendbarkeit

### 3. Vereinfachte KI-Architektur

**Problem**: Die aktuelle Struktur suggeriert komplexe Provider-Verwaltung.

**Lösung**:
- Einheitliche Schnittstelle über gollm
- Vereinfachte Konfiguration
- Klare Trennung von KI-Funktionalität

### 4. Konsolidierte Konfigurationsverwaltung

**Problem**: Konfiguration ist über mehrere Dateien verteilt.

**Lösung**:
- Einheitlicher `config.Manager` in `internal/config/`
- Klare Trennung von Laden, Validierung und Speichern
- Vereinfachte API-Schlüssel-Verwaltung

### 5. Strukturierte UI-Komponenten

**Problem**: UI-Code ist in `models/` statt in UI-spezifischen Paketen.

**Lösung**:
- Alle Bubble Tea-Komponenten in `internal/ui/`
- Wiederverwendbare Komponenten
- Konsistente Stile

## Migrationsplan

### Phase 1: Strukturelle Reorganisation

1. **Neue Verzeichnisstruktur erstellen**
   ```bash
   mkdir -p internal/{cli/commands,core/{changelog,ai,git},config,ui/{models,components},utils}
   mkdir -p pkg/version
   ```

2. **CLI-Befehle migrieren**
   ```bash
   # Von pkg/commands/* nach internal/cli/commands/
   mv pkg/commands/changelog/cmd.go internal/cli/commands/changelog.go
   mv pkg/commands/initialize/cmd.go internal/cli/commands/init.go
   mv pkg/commands/version/cmd.go internal/cli/commands/version.go
   mv pkg/commands/root/cmd.go internal/cli/commands/root.go
   ```

3. **Geschäftslogik extrahieren**
   ```bash
   # Changelog-Kernlogik
   mv pkg/internal/changelog/* internal/core/changelog/
   
   # KI-Logik konsolidieren
   mv pkg/ai/* internal/core/ai/
   
   # Git-Operationen
   mkdir internal/core/git
   # Git-bezogene Funktionen aus changelog extrahieren
   ```

4. **Konfiguration konsolidieren**
   ```bash
   mv pkg/config/* internal/config/
   ```

5. **UI-Komponenten reorganisieren**
   ```bash
   mv models/initialize/* internal/ui/models/
   mv internal/ui/components/* internal/ui/components/ # falls vorhanden
   ```

6. **Utils migrieren**
   ```bash
   mv pkg/utils/* internal/utils/
   ```

### Phase 2: Code-Refactoring

1. **Import-Pfade aktualisieren**
   - Alle Imports von `clikd/pkg/*` auf `clikd/internal/*` ändern
   - Öffentliche APIs in `pkg/` belassen

2. **CLI-Befehle vereinfachen**
   ```go
   // Vorher: pkg/commands/changelog/cmd.go
   func NewChangelogCmd() *cobra.Command {
       // Viel Geschäftslogik hier
   }
   
   // Nachher: internal/cli/commands/changelog.go
   func NewChangelogCmd() *cobra.Command {
       return &cobra.Command{
           Use: "changelog",
           RunE: func(cmd *cobra.Command, args []string) error {
               return changelog.Generate(/* params */)
           },
       }
   }
   ```

3. **Geschäftslogik extrahieren**
   ```go
   // internal/core/changelog/generator.go
   package changelog
   
   type Generator struct {
       config *config.Config
       ai     *ai.Client
       git    *git.Repository
   }
   
   func (g *Generator) Generate(opts GenerateOptions) error {
       // Gesamte Changelog-Generierungslogik
   }
   ```

4. **KI-Integration konsolidieren**
   ```go
   // internal/core/ai/client.go
   package ai
   
   type Client struct {
       gollm gollm.LLM
   }
   
   func NewClient(config *config.AIConfig) (*Client, error) {
       // Einheitliche gollm-Initialisierung
   }
   ```

### Phase 3: Konfiguration vereinfachen

1. **Einheitlicher Konfigurationsmanager**
   ```go
   // internal/config/manager.go
   type Manager struct {
       config *Config
       path   string
   }
   
   func (m *Manager) Load() error
   func (m *Manager) Save() error
   func (m *Manager) GetAIConfig() *AIConfig
   ```

2. **API-Schlüssel-Verwaltung vereinfachen**
   ```go
   // internal/config/apikey.go
   func GetAPIKey(provider string) (string, error) {
       // Einheitliche Logik für alle Provider
   }
   ```

### Phase 4: UI-Komponenten strukturieren

1. **Bubble Tea Models organisieren**
   ```go
   // internal/ui/models/init.go
   type InitModel struct {
       // Initialisierungslogik
   }
   ```

2. **Wiederverwendbare Komponenten**
   ```go
   // internal/ui/components/select.go
   func NewSelectComponent(options []string) SelectComponent
   ```

### Phase 5: Tests und Dokumentation

1. **Tests aktualisieren**
   - Import-Pfade in Tests korrigieren
   - Neue Struktur in Tests reflektieren

2. **Dokumentation aktualisieren**
   - README.md mit neuer Struktur
   - Entwicklerdokumentation

## Vorteile der neuen Struktur

### 1. Klarheit und Verständlichkeit
- Eindeutige Trennung zwischen öffentlichen und privaten APIs
- Logische Gruppierung verwandter Funktionalität
- Selbsterklärende Verzeichnisstruktur

### 2. Wartbarkeit
- Geschäftslogik unabhängig von CLI-Framework
- Modulare Komponenten
- Einfachere Fehlersuche

### 3. Testbarkeit
- Geschäftslogik ohne CLI-Abhängigkeiten testbar
- Isolierte Komponenten
- Bessere Mocking-Möglichkeiten

### 4. Erweiterbarkeit
- Neue Befehle einfach hinzufügbar
- KI-Funktionen modular erweiterbar
- UI-Komponenten wiederverwendbar

### 5. Go-Konformität
- Korrekte Verwendung von `internal/` vs. `pkg/`
- Standard Go-Projektlayout
- Bessere Integration in Go-Toolchain

## Potenzielle Herausforderungen

### 1. Import-Pfad-Migration
**Herausforderung**: Viele Import-Pfade müssen geändert werden.
**Lösung**: Schrittweise Migration mit automatisierten Tools.

### 2. Abhängigkeiten zwischen Paketen
**Herausforderung**: Zirkuläre Abhängigkeiten vermeiden.
**Lösung**: Klare Abhängigkeitshierarchie definieren.

### 3. Bestehende Konfigurationen
**Herausforderung**: Benutzer-Konfigurationen bleiben kompatibel.
**Lösung**: Migrations-Skripte für Konfigurationsdateien.

## Implementierungsschritte

### Schritt 1: Vorbereitung (1-2 Tage)
- Backup der aktuellen Codebase
- Neue Verzeichnisstruktur erstellen
- Migrations-Skripte vorbereiten

### Schritt 2: Strukturelle Migration (3-4 Tage)
- Dateien in neue Struktur verschieben
- Import-Pfade aktualisieren
- Grundlegende Kompilierbarkeit sicherstellen

### Schritt 3: Code-Refactoring (5-7 Tage)
- CLI-Befehle vereinfachen
- Geschäftslogik extrahieren
- KI-Integration konsolidieren

### Schritt 4: Konfiguration vereinfachen (2-3 Tage)
- Einheitlichen Manager implementieren
- API-Schlüssel-Verwaltung vereinfachen
- Migrations-Logik für bestehende Konfigurationen

### Schritt 5: UI-Reorganisation (2-3 Tage)
- Bubble Tea Models strukturieren
- Wiederverwendbare Komponenten erstellen
- Stile konsolidieren

### Schritt 6: Tests und Qualitätssicherung (3-4 Tage)
- Alle Tests aktualisieren
- Integration Tests durchführen
- Dokumentation aktualisieren

### Schritt 7: Validierung (1-2 Tage)
- End-to-End Tests
- Performance-Validierung
- Benutzer-Feedback einholen

## Erfolgskriterien

1. **Funktionalität**: Alle bestehenden Features funktionieren unverändert
2. **Performance**: Keine Verschlechterung der Ausführungszeit
3. **Wartbarkeit**: Code ist einfacher zu verstehen und zu erweitern
4. **Testabdeckung**: Mindestens gleiche Testabdeckung wie vorher
5. **Dokumentation**: Vollständige Dokumentation der neuen Struktur

## Fazit

Die vorgeschlagene Restrukturierung adressiert die identifizierten Probleme der aktuellen Codebase und schafft eine solide Grundlage für die Weiterentwicklung von clikd. Die neue Struktur folgt Go-Best-Practices, verbessert die Wartbarkeit und macht die Anwendung zukunftssicher.

Die Migration kann schrittweise durchgeführt werden, um das Risiko zu minimieren und die Kontinuität der Entwicklung zu gewährleisten. 
