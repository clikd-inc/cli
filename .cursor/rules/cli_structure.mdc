---
description: 
globs: 
alwaysApply: true
---
# CLI Architecture for clikd

Diese Regel definiert die grundlegende Architektur, Struktur und Standardpraktiken für die Implementierung von Unterbefehlen und Funktionalitäten in der clikd CLI.

## Directory Structure

- **`cmd/clikd/`**: Enthält nur den Haupteintrittspunkt (`main.go`) der CLI
  - Hauptaufgabe: Root-Befehl definieren, Unterbefehle registrieren, globale Flags und Konfiguration laden

- **`pkg/commands/{command}/`**: Enthält die CLI-Schnittstelle für jeden Unterbefehl 
  - Hauptaufgabe: Definition von Cobra-Befehlen, Flags und Unterbefehlen
  - Datei `cmd.go`: Definiert den Hauptunterbefehl und exportiert `New{Command}Cmd()`
  - Kann zusätzliche Dateien enthalten, die weitere Unterbefehle definieren

- **`pkg/internal/{module}/`**: Enthält die eigentliche Implementierung der Funktionalität
  - Hauptaufgabe: Kernlogik, unabhängig von CLI-Aspekten implementiert
  - Kann in mehrere Dateien aufgeteilt werden, die verschiedene Aspekte der Funktionalität implementieren

- **`pkg/config/`**: Gemeinsame Konfigurationslogik für die gesamte CLI
  - Hauptaufgabe: Viper-Konfiguration, Laden von Konfigurationsdateien, Umgebungsvariablen

- **`pkg/utils/`**: Gemeinsame Hilfsfunktionen für die gesamte CLI
  - Hauptaufgabe: Wiederverwendbare Funktionen wie Logging, Fehlerbehandlung, etc.

## Standards für die Befehlsimplementierung

### 1. Hinzufügen neuer Befehle

```go
// In pkg/commands/{command}/cmd.go
package {command}

import (
    "github.com/spf13/cobra"
    // Andere notwendige Imports
)

// New{Command}Cmd erstellt einen neuen Befehl für {Beschreibung}
func New{Command}Cmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "{command} [flags] [args]",
        Short: "Kurzbeschreibung",
        Long:  `Ausführliche Beschreibung über mehrere Zeilen.`,
        RunE: func(cmd *cobra.Command, args []string) error {
            // Implementierung oder Aufruf der eigentlichen Funktionalität
            return nil
        },
    }
    
    // Flags hinzufügen
    cmd.Flags().StringVarP(&variableName, "flag-name", "f", "default", "Beschreibung")
    
    // Unterbefehle hinzufügen (optional)
    cmd.AddCommand(newSubCommand())
    
    return cmd
}
```

### 2. Registrierung im Root-Befehl

```go
// In cmd/clikd/main.go
import (
    // Andere Imports
    "clikd/pkg/commands/{command}"
)

func newRootCmd() *cobra.Command {
    // Root-Befehl erstellen
    
    // Befehle hinzufügen
    rootCmd.AddCommand({command}.New{Command}Cmd())
    
    return rootCmd
}
```

### 3. Implementierung der Kernfunktionalität

```go
// In pkg/internal/{module}/{file}.go
package {module}

// Funktionen, Strukturen und Methoden implementieren
// Diese sollten unabhängig von der CLI-Schnittstelle sein
```

## Konfigurationsmanagement

### 1. Allgemeine Konfiguration

- Viper für globale Konfiguration verwenden
- Konfigurationswerte werden aus folgenden Quellen geladen (in Reihenfolge der Priorität):
  1. Befehlszeilenargumente
  2. Umgebungsvariablen (mit Präfix `CLIKD_`)
  3. Globale Konfigurationsdatei (`$HOME/.clikd/config.toml`)
  4. Lokale Konfigurationsdatei (`./clikd/config.toml`)

### 2. Befehlsspezifische Konfiguration

- Jeder Unterbefehl kann eigene Konfigurationswerte definieren
- Diese sollten unter einem dedizierten Schlüssel in der globalen Konfiguration gespeichert werden
- Beispiel:
  ```toml
  # In $HOME/.clikd/config.toml oder ./clikd/config.toml
  [general]
  log_level = "info"
  
  # Befehlsspezifische Konfiguration
  [changelog]
    style = "github"
    template = "templates/changelog.md"
  ```

### 3. KI-Konfiguration und API-Schlüssel-Management

- KI-Konfiguration verwendet ein vereinfachtes Modell mit einem Provider und einem Modell
- Die Konfiguration validiert automatisch, ob das gewählte Modell mit dem gewählten Provider kompatibel ist
- API-Schlüssel werden AUSSCHLIESSLICH aus zwei Quellen geladen:
  1. Für lokale Repository-Projekte: Aus der `.env`-Datei im Projektverzeichnis
  2. Für globale Operationen: Aus der globalen Konfigurationsdatei (`$HOME/.clikd/config.toml`)
- Shell-Umgebungsvariablen werden NIEMALS direkt als Quelle für API-Schlüssel verwendet
- Die vereinfachte KI-Konfiguration in der globalen Konfigurationsdatei sieht wie folgt aus:
  ```toml
  [ai]
  enable = true
  provider = "mistral"
  model = "mistral-medium"
  api_key = "sk-..." # Nur in globaler Konfiguration
  ```

- Beispiel für eine lokale `.env`-Datei:
  ```
  # API-Schlüssel für lokales Projekt
  CLIKD_MISTRAL_API_KEY=sk-...
  CLIKD_OPENAI_API_KEY=sk-...
  ```

- Für die Schlüsselabfrage ist die Funktion `utils.GetAPIKey()` zu verwenden, die die korrekte Hierarchie implementiert
- Wenn kein API-Schlüssel für den konfigurierten Provider gefunden wird, zeigt das System automatisch hilfreiche Fehlermeldungen an:
  ```
  API-Schlüssel für Mistral nicht gefunden. Sie können den Schlüssel auf folgende Weise hinzufügen:

  1. Erstellen Sie eine .env-Datei im Projektverzeichnis und fügen Sie hinzu:
     CLIKD_MISTRAL_API_KEY=ihr_api_schlüssel

  2. Oder fügen Sie den Schlüssel zu Ihrer globalen Konfiguration hinzu:
     clikd config set ai.api_key ihr_api_schlüssel

  Um einen API-Schlüssel zu erhalten, besuchen Sie die Website des Anbieters: https://console.mistral.ai/api-keys/
  ```

- Wenn eine ungültige Provider-Modell-Kombination konfiguriert wird, erfolgt eine Validierung mit hilfreichen Vorschlägen:
  ```
  Fehler: Modell 'gpt-4' wird nicht vom Provider 'mistral' unterstützt.
  Unterstützte Modelle für Mistral: mistral-medium, mistral-small, mistral-large
  ```

- Beispiel für einen API-Schlüsselabruf in der Befehlsimplementierung:
  ```go
  // KI-Konfiguration abrufen
  aiConfig, err := config.GetAIModelConfig("")
  if err != nil {
      return err // Validierungsfehler oder fehlender API-Schlüssel mit Anweisungen
  }
  
  // Client mit der Konfiguration erstellen
  client, err := ai.NewClient(ctx, aiConfig)
  if err != nil {
      return fmt.Errorf("Fehler beim Erstellen des KI-Clients: %w", err)
  }
  
  // Client verwenden...
  ```

## Fehlerbehandlung und Logging

- Den gemeinsamen Logger aus `pkg/utils/logger.go` verwenden
- Fehler sollten an den Cobra-Befehl weitergegeben werden
- Kontextbezogene Fehlermeldungen mit `fmt.Errorf("Kontext: %w", err)` verwenden

## Integration externer Befehle

Bei der Integration externer CLI-Tools als Unterbefehle:

1. Die Kernfunktionalität in `pkg/internal/{module}/` kopieren
2. Paketnamen und Import-Pfade anpassen
3. Eine Wrapper-Schnittstelle in `pkg/commands/{command}/` erstellen
4. Die ursprüngliche Funktionalität beibehalten, nur die Schnittstelle ändern

## Best Practices

- **✅ DO**: Trennung von CLI-Schnittstelle und Kernfunktionalität beibehalten
- **✅ DO**: Globale Flags für allgemeine Optionen verwenden (z.B. `--verbose`, `--config`)
- **✅ DO**: Hilfreiche Dokumentation und Beispiele in `cmd.Long` bereitstellen
- **✅ DO**: Unterstützung für Umgebungsvariablen bieten
- **✅ DO**: API-Schlüssel nur in globaler Konfiguration speichern oder aus .env-Dateien laden
- **✅ DO**: Bei lokaler Konfiguration immer API-Schlüssel aus `.env` laden oder Benutzer informieren
- **✅ DO**: Validieren, ob die gewählte Provider-Modell-Kombination kompatibel ist

- **❌ DON'T**: Geschäftslogik in `pkg/commands` implementieren
- **❌ DON'T**: Zu viele Ebenen von Unterbefehlen erstellen (max. 2-3)
- **❌ DON'T**: Hartcodierte Pfade oder Konfigurationswerte verwenden
- **❌ DON'T**: API-Schlüssel in Repository-spezifischen Konfigurationen oder im Code speichern
- **❌ DON'T**: Globale API-Schlüssel ohne Einverständnis des Benutzers in einem lokalen Projekt verwenden
- **❌ DON'T**: Unnötige Parameter wie Temperature, TopP oder ContextWindow in der Konfiguration mitführen

## Testbarkeit

- Tests für Kernfunktionalität in `pkg/internal/{module}/{file}_test.go` implementieren
- Für CLI-Tests kann `github.com/spf13/cobra/command.SetArgs()` verwendet werden
- Validierungsfunktionen für Provider-Modell-Kombinationen sollten eigene Tests haben

## Kompatibilität bei der Integration

Bei der Integration externer CLI-Tools:
- Das ursprüngliche Flag-Verhalten beibehalten
- Änderungen am ursprünglichen Verhalten dokumentieren
- Sicherstellen, dass alle Funktionen des ursprünglichen Tools unterstützt werden

globs: cmd/**, pkg/**, internal/**
