---
description: 
globs: 
alwaysApply: true
---
# CLI Architecture for clikd

Diese Regel definiert die grundlegende Architektur, Struktur und Standardpraktiken für die Implementierung von Unterbefehlen und Funktionalitäten in der clikd CLI.

## Directory Structure

- **`cmd/clikd/`**: Enthält nur den Haupteintrittspunkt (`main.go`) der CLI
  - Hauptaufgabe: Root-Befehl definieren, Unterbefehle registrieren, globale Flags und Konfiguration laden

- **`pkg/commands/{command}/`**: Enthält die CLI-Schnittstelle für jeden Unterbefehl 
  - Hauptaufgabe: Definition von Cobra-Befehlen, Flags und Unterbefehlen
  - Datei `cmd.go`: Definiert den Hauptunterbefehl und exportiert `New{Command}Cmd()`
  - Kann zusätzliche Dateien enthalten, die weitere Unterbefehle definieren
  - Datei `ui.go`: Enthält interaktive Bubble Tea-basierte UI-Implementierungen (wenn verwendet)

- **`pkg/internal/{module}/`**: Enthält die eigentliche Implementierung der Funktionalität
  - Hauptaufgabe: Kernlogik, unabhängig von CLI-Aspekten implementiert
  - Kann in mehrere Dateien aufgeteilt werden, die verschiedene Aspekte der Funktionalität implementieren

- **`pkg/config/`**: Gemeinsame Konfigurationslogik für die gesamte CLI
  - Hauptaufgabe: Viper-Konfiguration, Laden von Konfigurationsdateien, Umgebungsvariablen

- **`pkg/utils/`**: Gemeinsame Hilfsfunktionen für die gesamte CLI
  - Hauptaufgabe: Wiederverwendbare Funktionen wie Logging, Fehlerbehandlung, etc.

- **`pkg/ui/`**: Enthält das modulare UI-System für interaktive Benutzeroberflächen
  - **`pkg/ui/components/`**: Wiederverwendbare UI-Komponenten (Select, Input, Confirm, etc.)
  - **`pkg/ui/styles.go`**: Gemeinsame Stile und Design-Tokens für konsistentes Aussehen
  - Basiert auf dem Bubble Tea Framework für Terminal-UIs

## Standards für die Befehlsimplementierung

### 1. Hinzufügen neuer Befehle

```go
// In pkg/commands/{command}/cmd.go
package {command}

import (
    "github.com/spf13/cobra"
    // Andere notwendige Imports
)

// New{Command}Cmd erstellt einen neuen Befehl für {Beschreibung}
func New{Command}Cmd() *cobra.Command {
    cmd := &cobra.Command{
        Use:   "{command} [flags] [args]",
        Short: "Kurzbeschreibung",
        Long:  `Ausführliche Beschreibung über mehrere Zeilen.`,
        RunE: func(cmd *cobra.Command, args []string) error {
            // Implementierung oder Aufruf der eigentlichen Funktionalität
            return nil
        },
    }
    
    // Flags hinzufügen
    cmd.Flags().StringVarP(&variableName, "flag-name", "f", "default", "Beschreibung")
    
    // Unterbefehle hinzufügen (optional)
    cmd.AddCommand(newSubCommand())
    
    return cmd
}
```

### 2. Implementierung interaktiver Benutzeroberflächen

Für interaktive Befehle kann die moderne Bubble Tea-basierte UI verwendet werden:

```go
// In pkg/commands/{command}/ui.go
package {command}

import (
    "clikd/pkg/ui"
    "clikd/pkg/ui/components"
)

// run{Command}WithBubbleTea führt den Befehl mit moderner UI aus
func run{Command}WithBubbleTea(options ...any) error {
    // Komponenten verwenden
    result := components.RunSelect("Titel", items)
    
    // oder
    confirmed := components.Confirm("Titel", "Nachricht")
    
    // oder
    input := components.RunInput("Titel", "Beschreibung", "Platzhalter")
    
    // Progress anzeigen
    components.RunProgress("Titel", "Beschreibung", func(setPercent, setDone) {
        // Arbeitsschritte ausführen
        setPercent(0.5) // 50%
        setDone()
    })
    
    return nil
}
```

### 3. Registrierung im Root-Befehl

```go
// In cmd/clikd/main.go
import (
    // Andere Imports
    "clikd/pkg/commands/{command}"
)

func newRootCmd() *cobra.Command {
    // Root-Befehl erstellen
    
    // Befehle hinzufügen
    rootCmd.AddCommand({command}.New{Command}Cmd())
    
    return rootCmd
}
```

### 4. Implementierung der Kernfunktionalität

```go
// In pkg/internal/{module}/{file}.go
package {module}

// Funktionen, Strukturen und Methoden implementieren
// Diese sollten unabhängig von der CLI-Schnittstelle sein
```

## Konfigurationsmanagement

### 1. Allgemeine Konfiguration

- Viper für globale Konfiguration verwenden
- Konfigurationswerte werden aus folgenden Quellen geladen (in Reihenfolge der Priorität):
  1. Befehlszeilenargumente
  2. Umgebungsvariablen (mit Präfix `CLIKD_`)
  3. Globale Konfigurationsdatei (`$HOME/.clikd/config.toml`)
  4. Lokale Konfigurationsdatei (`./clikd/config.toml`)

### 2. Befehlsspezifische Konfiguration

- Jeder Unterbefehl kann eigene Konfigurationswerte definieren
- Diese sollten unter einem dedizierten Schlüssel in der globalen Konfiguration gespeichert werden
- Beispiel:
  ```toml
  # In $HOME/.clikd/config.toml oder ./clikd/config.toml
  [general]
  log_level = "info"
  
  # Befehlsspezifische Konfiguration
  [changelog]
    style = "github"
    template = "templates/changelog.md"
  ```

### 3. KI-Konfiguration und API-Schlüssel-Management

- KI-Konfiguration verwendet ein vereinfachtes Modell mit einem Provider und einem Modell
- Die Konfiguration validiert automatisch, ob das gewählte Modell mit dem gewählten Provider kompatibel ist
- API-Schlüssel werden AUSSCHLIESSLICH aus zwei Quellen geladen:
  1. Für lokale Repository-Projekte: Aus der `.env`-Datei im Projektverzeichnis mit `CLIKD_API_KEY`
  2. Für globale Operationen: Aus der globalen Konfigurationsdatei (`$HOME/.clikd/config.toml`) mit `ai.api_key`
- Shell-Umgebungsvariablen werden NIEMALS direkt als Quelle für API-Schlüssel verwendet
- Die vereinfachte KI-Konfiguration in der globalen Konfigurationsdatei sieht wie folgt aus:
  ```toml
  [ai]
  enable = true
  provider = "mistral"
  model = "mistral-medium"
  api_key = "sk-..." # Nur in globaler Konfiguration
  ```

- Beispiel für eine lokale `.env`-Datei:
  ```
  # API-Schlüssel für lokales Projekt (vereinfachtes Modell)
  CLIKD_API_KEY=sk-...
  ```

- Für die Schlüsselabfrage ist die Funktion `utils.GetAPIKey()` zu verwenden, die die korrekte Hierarchie implementiert
- Wenn kein API-Schlüssel gefunden wird, zeigt das System automatisch hilfreiche Fehlermeldungen an:
  ```
  API-Schlüssel nicht gefunden. Sie können den Schlüssel auf folgende Weise hinzufügen:

  1. Erstellen Sie eine .env-Datei im Projektverzeichnis und fügen Sie hinzu:
     CLIKD_API_KEY=ihr_api_schlüssel

  2. Oder fügen Sie den Schlüssel zu Ihrer globalen Konfiguration hinzu:
     clikd init config set ai.api_key=ihr_api_schlüssel

  Um einen API-Schlüssel zu erhalten, besuchen Sie die Website des Anbieters: https://console.mistral.ai/api-keys/
  ```

- Wenn eine ungültige Provider-Modell-Kombination konfiguriert wird, erfolgt eine Validierung mit hilfreichen Vorschlägen:
  ```
  Fehler: Modell 'gpt-4' wird nicht vom Provider 'mistral' unterstützt.
  Unterstützte Modelle für Mistral: mistral-medium, mistral-small, mistral-large
  ```

- Beispiel für einen API-Schlüsselabruf in der Befehlsimplementierung:
  ```go
  // KI-Konfiguration abrufen
  aiConfig, err := config.GetAIModelConfig("")
  if err != nil {
      return err // Validierungsfehler oder fehlender API-Schlüssel mit Anweisungen
  }
  
  // Client mit der Konfiguration erstellen
  client, err := ai.NewClient(ctx, aiConfig)
  if err != nil {
      return fmt.Errorf("Fehler beim Erstellen des KI-Clients: %w", err)
  }
  
  // Client verwenden...
  ```

## UI-System (Bubble Tea)

Das modulare UI-System basiert auf Bubble Tea und bietet folgende Komponenten:

- **Select**: Auswahl aus einer Liste von Optionen
- **Multiselect**: Mehrfachauswahl aus einer Liste von Optionen
- **Input**: Textfeld für Benutzereingaben
- **PasswordInput**: Maskiertes Textfeld für sensible Eingaben
- **Confirm**: Ja/Nein-Bestätigungsdialog
- **Progress**: Fortschrittsanzeige für längere Operationen
- **List**: Formatierte Listen mit optionalen Tags und Status
- **Message**: Informations- und Hinweisdialoge

Die Komponenten verwenden ein einheitliches Styling und Design-System, das in `pkg/ui/styles.go` definiert ist.

### Beispiel für die Verwendung des UI-Systems:

```go
// Provider auswählen
providerItems := make([]components.SelectItem, len(providerOptions))
for i, provider := range providerOptions {
    providerItems[i] = components.SelectItem{
        Title:       provider,
        Description: fmt.Sprintf("Standardmodell: %s", defaultModel),
        Value:       provider,
    }
}

selectedProvider := components.RunSelect("Wählen Sie einen Provider", providerItems)
if selectedProvider == nil {
    return fmt.Errorf("abbruch durch Benutzer")
}

provider := selectedProvider.Value.(string)
```

## Fehlerbehandlung und Logging

- Den gemeinsamen Logger aus `pkg/utils/logger.go` verwenden
- Fehler sollten an den Cobra-Befehl weitergegeben werden
- Kontextbezogene Fehlermeldungen mit `fmt.Errorf("Kontext: %w", err)` verwenden

## Integration externer Befehle

Bei der Integration externer CLI-Tools als Unterbefehle:

1. Die Kernfunktionalität in `pkg/internal/{module}/` kopieren
2. Paketnamen und Import-Pfade anpassen
3. Eine Wrapper-Schnittstelle in `pkg/commands/{command}/` erstellen
4. Die ursprüngliche Funktionalität beibehalten, nur die Schnittstelle ändern

## Best Practices

- **✅ DO**: Trennung von CLI-Schnittstelle und Kernfunktionalität beibehalten
- **✅ DO**: Globale Flags für allgemeine Optionen verwenden (z.B. `--verbose`, `--config`)
- **✅ DO**: Hilfreiche Dokumentation und Beispiele in `cmd.Long` bereitstellen
- **✅ DO**: Unterstützung für Umgebungsvariablen bieten
- **✅ DO**: API-Schlüssel nur in globaler Konfiguration speichern oder aus .env-Dateien laden
- **✅ DO**: Bei lokaler Konfiguration immer API-Schlüssel aus `.env` laden oder Benutzer informieren
- **✅ DO**: Validieren, ob die gewählte Provider-Modell-Kombination kompatibel ist
- **✅ DO**: Moderne UI mit Bubble Tea für interaktive Befehle verwenden

- **❌ DON'T**: Geschäftslogik in `pkg/commands` implementieren
- **❌ DON'T**: Zu viele Ebenen von Unterbefehlen erstellen (max. 2-3)
- **❌ DON'T**: Hartcodierte Pfade oder Konfigurationswerte verwenden
- **❌ DON'T**: API-Schlüssel in Repository-spezifischen Konfigurationen oder im Code speichern
- **❌ DON'T**: Globale API-Schlüssel ohne Einverständnis des Benutzers in einem lokalen Projekt verwenden
- **❌ DON'T**: Unnötige Parameter wie Temperature, TopP oder ContextWindow in der Konfiguration mitführen
- **❌ DON'T**: Provider-spezifische API-Schlüssel verwenden, stattdessen das vereinfachte Modell mit `CLIKD_API_KEY` verwenden

## Testbarkeit

- Tests für Kernfunktionalität in `pkg/internal/{module}/{file}_test.go` implementieren
- Für CLI-Tests kann `github.com/spf13/cobra/command.SetArgs()` verwendet werden
- Validierungsfunktionen für Provider-Modell-Kombinationen sollten eigene Tests haben

## Kompatibilität bei der Integration

Bei der Integration externer CLI-Tools:
- Das ursprüngliche Flag-Verhalten beibehalten
- Änderungen am ursprünglichen Verhalten dokumentieren
- Sicherstellen, dass alle Funktionen des ursprünglichen Tools unterstützt werden

globs: cmd/**, pkg/**, internal/**
